theory H_Ab
  imports Main
         "HOL-Algebra.Group"
         pointedSet
begin


lemma fmap_length : "length (fmap f xs) = length xs"
  by simp

lemma fmap_preserves_inj : assumes xs_ys_eq: "fmap f xs = fmap f ys" 
and f_inj: "(\<And>x y. f x = f y \<Longrightarrow> x = y)"
  shows "xs = ys"
proof-
  show "xs = ys"
    apply (rule_tac getFaithful)
  proof-
    from xs_ys_eq have "length (fmap f xs) = length (fmap f ys)"
      by simp
    then show "length xs = length ys" using fmap_length by simp
    fix n
    assume "n < length xs"
    then have "n < length ys"
      using \<open>length xs = length ys\<close> by simp
    have eq_x: "get (rev_get (length xs) (\<lambda>n. f (get xs n))) n = f (get xs n)"
      by (simp add: get_rev_get [OF \<open>n < length xs\<close>])
    have eq_y: "get (rev_get (length ys) (\<lambda>n. f (get ys n))) n = f (get ys n)"
      by (simp add: get_rev_get [OF \<open>n < length ys\<close>])
    have "get (rev_get (length xs) (\<lambda>n. f (get xs n))) n = get (rev_get (length ys) (\<lambda>n. f (get ys n))) n"
      using xs_ys_eq by simp
    from this and eq_x and eq_y have "f (get xs n) = f (get ys n)" by simp
    then show "get xs n = get ys n"
      apply (rule_tac f_inj)
      by simp
  qed
qed



lemma fmap_image : assumes xs_in_S: "\<forall>k < length xs . get xs k \<in> f ` S"
  shows "\<exists> as. xs = fmap f as \<and> (\<forall>k < length xs. get as k \<in> S)"
proof
  define as where "as = rev_get (length xs) (\<lambda>k. (SOME a. get xs k = f a \<and> a \<in> S))"
  have length_eq : "length as = length xs" unfolding as_def by simp
  show "xs = fmap f as \<and> (\<forall>k<length xs. get as k \<in> S)"
    apply auto
     apply (rule_tac getFaithful)
    unfolding as_def apply simp
     apply (simp_all add: get_rev_get)
  proof-
    fix k
    assume "k < length xs"
    define P where "P = (\<lambda>a. get xs k = f a \<and> a \<in> S)"
    have ex_a: "\<exists>a. P a"
      unfolding P_def
      using xs_in_S \<open>k < length xs\<close> by auto
    have p_a: "P (SOME a. P a)"
      using someI_ex [OF ex_a].
    from p_a show "get xs k = f (SOME a. get xs k = f a \<and> a \<in> S)"
      unfolding P_def by simp
    from p_a show "(SOME a. get xs k = f a \<and> a \<in> S) \<in> S"
      unfolding P_def by simp
  qed
qed







section "Abelian Groups to Gammaset"

locale GroupToGammaset =
  G: comm_group G
  for G:: "('a,'b) monoid_scheme"
begin

interpretation pointed_set.


term pointed_product

definition merge_with_zeros :: "'a list \<Rightarrow> (nat \<Rightarrow> bool) \<Rightarrow> 'a list" where
  "merge_with_zeros xs P = rev_get (length xs) (\<lambda>k. if P k then (get xs k) else \<one>\<^bsub>G\<^esub>)"

lemma merge_with_zeros_length [simp]: "length (merge_with_zeros xs P) = length xs"
  unfolding merge_with_zeros_def by simp

lemma merge_with_zeros_add : "merge_with_zeros (a # as) P = 
     (if P 0 then a else \<one>\<^bsub>G\<^esub>) # (merge_with_zeros as (\<lambda>i. P (Suc i)))"
  unfolding merge_with_zeros_def
  apply (rule_tac getFaithful)
   apply (simp add: app_length)
proof-
  fix n
  assume "n < length (rev_get (length (a # as)) (\<lambda>k. if P k then get (a # as) k else \<one>\<^bsub>G\<^esub>))"
  then have "n < length (a # as)" by (simp add: app_length)
  have "n < length (a # as) \<Longrightarrow> get (rev_get (length (a # as)) (\<lambda>k. if P k then get (a # as) k else \<one>\<^bsub>G\<^esub>)) n =
         get ((if P 0 then a else \<one>\<^bsub>G\<^esub>) # rev_get (length as) (\<lambda>k. if P (Suc k) then get as k else \<one>\<^bsub>G\<^esub>)) n"
    apply (subst get_rev_get [OF \<open>n < length (a # as)\<close>])
    apply (induction n)
     apply simp
    by (simp add: get_rev_get)
  then show "get (rev_get (length (a # as)) (\<lambda>k. if P k then get (a # as) k else \<one>\<^bsub>G\<^esub>)) n =
         get ((if P 0 then a else \<one>\<^bsub>G\<^esub>) # rev_get (length as) (\<lambda>k. if P (Suc k) then get as k else \<one>\<^bsub>G\<^esub>)) n"
    using \<open>n < length (a # as)\<close> by simp
qed
    

fun sum :: "'a list \<Rightarrow> 'a" where
  "sum [] = \<one>\<^bsub>G\<^esub>" |
  "sum (x # xs) = (\<otimes>\<^bsub>G\<^esub>) x (sum xs)"

lemma zero_sum: "\<forall>k < length xs. get xs k = \<one>\<^bsub>G\<^esub> \<Longrightarrow> sum xs = \<one>\<^bsub>G\<^esub>"
  apply (induction xs)
   apply simp
proof-
  fix a xs
  assume ind: "(\<forall>k<length xs. get xs k = \<one>\<^bsub>G\<^esub> \<Longrightarrow> local.sum xs = \<one>\<^bsub>G\<^esub>)"
  assume hyp: "\<forall>k<length (a # xs). get (a # xs) k = \<one>\<^bsub>G\<^esub>"
  from hyp have "\<forall>k<length xs. get xs k = \<one>\<^bsub>G\<^esub>" by auto
  then have sum_1: "local.sum xs = \<one>\<^bsub>G\<^esub>" using ind by simp
  from hyp have a_1: "a = \<one>\<^bsub>G\<^esub>" by auto
  show "local.sum (a # xs) = \<one>\<^bsub>G\<^esub>"
    using sum_1 a_1 by simp
qed






lemma one_sum :" (i < length xs \<and> (\<forall>k < length xs. k \<noteq> i \<longrightarrow> get xs k = \<one>\<^bsub>G\<^esub>)) \<and> 
          get xs i \<in> carrier G \<Longrightarrow> sum xs = get xs i"
  apply (induction xs arbitrary: i)
   apply simp
  apply auto
proof-
  fix a xs i
  assume ind: "(\<And>i. i < length xs \<and> (\<forall>k<length xs. k \<noteq> i \<longrightarrow> get xs k = \<one>\<^bsub>G\<^esub>) \<and>
             get xs i \<in> carrier G \<Longrightarrow> local.sum xs = get xs i)"
  assume in_G: "get (a # xs) i \<in> carrier G"
  assume "i < Suc (length xs)"
  assume hyp: "\<forall>k<Suc (length xs). k \<noteq> i \<longrightarrow> get (a # xs) k = \<one>\<^bsub>G\<^esub>" 
  have "i > 0 \<or> i = 0" by auto
  then show "a \<otimes>\<^bsub>G\<^esub> local.sum xs = get (a # xs) i"
  proof
    assume "i > 0"
    then have "i = Suc (i-1)" by simp
    then obtain j where j_def: "i = Suc j" by auto 
    have j_in_G: "get xs j \<in> carrier G"
      using j_def in_G by simp
    have "j < length xs \<and> (\<forall>k<length xs. k \<noteq> j \<longrightarrow> get xs k = \<one>\<^bsub>G\<^esub>) \<and> get xs j \<in> carrier G"
      apply safe
      using j_def \<open>i < Suc (length xs)\<close> apply simp
      using j_def hyp apply auto
      using j_in_G.
    then have sum_eq: "local.sum xs = get xs j"
      using ind by simp
    from \<open>i > 0\<close> have a_eq: "a = \<one>\<^bsub>G\<^esub>"
      using hyp by auto
    have "\<And>x. x \<in> carrier G \<Longrightarrow> \<one>\<^bsub>G\<^esub> \<otimes>\<^bsub>G\<^esub> x = x" by simp
    show "a \<otimes>\<^bsub>G\<^esub> local.sum xs = get (a # xs) i"
      apply (subst a_eq)
      apply (subst sum_eq)
      using j_in_G apply simp
      using j_def by simp
  next
    assume "i = 0"
    have "local.sum xs = \<one>\<^bsub>G\<^esub>"
      apply (rule_tac zero_sum)
      using hyp \<open>i = 0\<close> by auto
    then show "a \<otimes>\<^bsub>G\<^esub> local.sum xs = get (a # xs) i"
      using in_G \<open>i = 0\<close> by simp
  qed
qed







lemma sum_carrier : "\<forall>k < length xs. get xs k \<in> carrier G \<Longrightarrow> sum xs \<in> carrier G"
  apply (induction xs)
   apply simp
proof-
  fix a xs
  assume ind: " (\<forall>k<length xs. get xs k \<in> carrier G \<Longrightarrow> local.sum xs \<in> carrier G)"
  assume hyp: "\<forall>k<length (a # xs). get (a # xs) k \<in> carrier G"
  have "\<forall>k<length xs. get xs k \<in> carrier G"
    using hyp by auto
  then have sum_in_G: "local.sum xs \<in> carrier G"
    apply (rule_tac ind) 
    by simp
  from hyp have "get (a # xs) 0 \<in> carrier G"
    by blast
  then have a_in_G: "a \<in> carrier G"
    by simp
  show "local.sum (a # xs) \<in> carrier G"
    using a_in_G sum_in_G by simp
qed


lemma app_sum : assumes ys_in_G: "\<forall>k < length ys. get ys k \<in> carrier G"
  shows "\<forall>k < length xs. get xs k \<in> carrier G \<Longrightarrow> sum (app xs ys) = sum xs \<otimes>\<^bsub>G\<^esub> sum ys"
  apply (induction xs)
  using sum_carrier [OF ys_in_G] apply simp
proof-
  fix a xs
  assume ind: "(\<forall>k<length xs. get xs k \<in> carrier G \<Longrightarrow> local.sum (app xs ys) = local.sum xs \<otimes>\<^bsub>G\<^esub> local.sum ys)"
  assume hyp: "\<forall>k<length (a # xs). get (a # xs) k \<in> carrier G"
  then have "\<forall>k<length xs. get xs k \<in> carrier G" by auto
  then have ind_eq : "local.sum (app xs ys) = local.sum xs \<otimes>\<^bsub>G\<^esub> local.sum ys"
    using ind by simp
  have y_sum_in_G: "sum ys \<in> carrier G" using sum_carrier [OF ys_in_G].
  have x_sum_in_G: "sum xs \<in> carrier G" using sum_carrier [OF \<open>\<forall>k<length xs. get xs k \<in> carrier G\<close>].
  have a_in_G: "a \<in> carrier G" using hyp by auto
  show "local.sum (app (a # xs) ys) = local.sum (a # xs) \<otimes>\<^bsub>G\<^esub> local.sum ys"
    apply simp
    apply (subst ind_eq)
    using G.m_assoc [OF a_in_G x_sum_in_G y_sum_in_G]
    by simp
qed

lemma app_induction: assumes start: "P []" 
   and step: "(\<forall>a xs. P xs \<longrightarrow> P (app xs [a]))"
                  shows "P ys"
proof-
  define n where "n = length (ys)" 
  have "\<forall>xs. length xs = n \<longrightarrow> P xs"
    apply (induction n) 
    using start apply simp
  proof-
    fix n
    assume ind: "\<forall>xs. length xs = n \<longrightarrow> P xs"
    then have ind_rule : "\<And>xs. length xs = n \<Longrightarrow> P xs" by simp
    show "\<forall>xs. length xs = Suc n \<longrightarrow> P xs"
      apply auto
    proof-
      fix xs :: "'c list" 
      assume "length xs = Suc n"
      then obtain a ys where a_ys_def: "xs = app ys [a]"
        by (metis rev_get.simps(2) rev_get_get)
      from step have step_rule : "(P ys \<Longrightarrow> P (app ys [a]))" by simp
      show "P xs"
        apply (subst a_ys_def)
        apply (rule_tac step_rule)
        apply (rule_tac ind_rule)
        using \<open>length xs = Suc n\<close> a_ys_def
        by (simp add: app_length)
    qed
  qed
  then show "P ys"
    unfolding n_def by simp
qed
    





lemma binary_sum_sum : "\<forall>k < length ys. get ys k \<in> carrier G \<Longrightarrow> 
             \<forall>k < length xs. get xs k \<in> carrier G \<Longrightarrow>
                 length xs = length ys \<Longrightarrow>
               sum (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get ys k)) = sum xs \<otimes>\<^bsub>G\<^esub> sum ys"
proof-
  define P where "P = (\<lambda>xs. \<forall>ys. (\<forall>k < length ys. get ys k \<in> carrier G) \<longrightarrow>
                 (\<forall>k < length xs. get xs k \<in> carrier G) \<longrightarrow>
                 length xs = length ys \<longrightarrow>
               sum (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get ys k)) = sum xs \<otimes>\<^bsub>G\<^esub> sum ys)"
  have "\<forall>xs. P xs"
  proof
    fix xs
    show "P xs"
      apply (rule_tac app_induction)
    proof-
      show "P []"
        unfolding P_def
        by simp
      show "\<forall>a xs. P xs \<longrightarrow> P (app xs [a])"
        unfolding P_def apply auto
      proof-
        fix a xs ys
        assume ind: "\<forall>ys. (\<forall>k<length ys. get ys k \<in> carrier G) \<longrightarrow>
            (\<forall>k<length xs. get xs k \<in> carrier G) \<longrightarrow>
            length xs = length ys \<longrightarrow>
            local.sum (rev_get (length ys) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get ys k)) = local.sum xs \<otimes>\<^bsub>G\<^esub> local.sum ys"
        assume ys_in_G: "\<forall>k<length ys. get ys k \<in> carrier G"
        assume xsa_in_G: "\<forall>k<length ys. get (app xs [a]) k \<in> carrier G"
        assume length_eq: "length (app xs [a]) = length ys"
        have xs_in_G: "\<forall>k < length xs. get xs k \<in> carrier G"
          apply (rule_tac allI)
        proof
          fix k
          assume "k < length xs"
          then have "k < length (app xs [a])"
            apply (subst app_length)
            by simp
          then have "k < length ys"
            using length_eq by simp
          then have "get (app xs [a]) k \<in> carrier G"
            using xsa_in_G by simp
          then show "get xs k \<in> carrier G"
            using getAppLemma [OF \<open>k < length xs\<close>] by simp
        qed
        have "length xs < length ys"
          unfolding reverse_equality [OF length_eq]
                    app_length
          by simp
        then have "get (app xs [a]) (length xs) \<in> carrier G"
          using xsa_in_G by simp
        then have a_in_G: "a \<in> carrier G"
          unfolding getAppLemma2 by simp

        define zs where "zs = rev_get (length xs) (get ys)"
        have "length zs = length xs"
          unfolding zs_def by simp

        define b where "b = get ys (length xs)"
        have b_in_G : "b \<in> carrier G"
          unfolding b_def
          using ys_in_G length_eq
          unfolding app_length by simp

        have "ys = app zs [b]"
          apply (rule_tac getFaithful)
          unfolding reverse_equality [OF length_eq]
                    app_length
                    zs_def
           apply simp
          apply simp
        proof-
          fix n
          assume "n < Suc (length xs)"
          then have "n < length xs \<or> n = length xs" by auto
          then show "get ys n = get (app (rev_get (length xs) (get ys)) [b]) n"
          proof
            assume "n < length xs"
            then have "n < length (rev_get (length xs) (get ys))" by simp
            show "get ys n = get (app (rev_get (length xs) (get ys)) [b]) n"
              apply (subst getAppLemma [OF \<open>n < length (rev_get (length xs) (get ys))\<close>])
              using reverse_equality [OF get_rev_get [OF \<open>n < length xs\<close>]].
          next
            assume "n = length xs"
            then have "n = length (rev_get (length xs) (get ys))" by simp
            show "get ys n = get (app (rev_get (length xs) (get ys)) [b]) n"
              apply (subst \<open>n = length xs\<close>)
              apply (subst \<open>n = length (rev_get (length xs) (get ys))\<close>)
              apply (subst getAppLemma2)
              unfolding b_def by simp
          qed
        qed
        have zs_in_G: "(\<forall>k<length zs. get zs k \<in> carrier G)"
          unfolding zs_def apply (simp add: get_rev_get)
          using ys_in_G length_eq
          unfolding app_length by simp
        then have ind_hyp: "(\<forall>k<length zs. get zs k \<in> carrier G) \<and>
            (\<forall>k<length xs. get xs k \<in> carrier G) \<and>
            length xs = length zs"
          using xs_in_G zs_def by simp
        then have zs_sum_eq: "sum (rev_get (length zs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get zs k)) = sum xs \<otimes>\<^bsub>G\<^esub> sum zs"
          using ind by simp 

        have xs_sum_in_G: "sum xs \<in> carrier G"
          using sum_carrier [OF xs_in_G].
        have zs_sum_in_G: "sum zs \<in> carrier G"
          using sum_carrier [OF zs_in_G].


        have eq1: " local.sum (app xs [a]) \<otimes>\<^bsub>G\<^esub> local.sum ys = 
          local.sum xs \<otimes>\<^bsub>G\<^esub> local.sum zs \<otimes>\<^bsub>G\<^esub> (a \<otimes>\<^bsub>G\<^esub> b)"
          apply (subst \<open>ys = app zs [b]\<close>)
          apply (subst app_sum)
          using a_in_G apply simp
          using xs_in_G apply simp
          apply (subst app_sum)
          using b_in_G apply simp
          using zs_in_G apply simp
          apply (simp add: a_in_G b_in_G)
          apply (subst G.m_assoc [OF xs_sum_in_G a_in_G])
          using zs_sum_in_G b_in_G apply simp
          apply (subst G.m_assoc [OF xs_sum_in_G zs_sum_in_G])
          using a_in_G b_in_G apply simp
          apply (subst reverse_equality [OF G.m_assoc [OF a_in_G zs_sum_in_G b_in_G]])
          apply (subst reverse_equality [OF G.m_assoc [OF zs_sum_in_G a_in_G b_in_G]])
          using G.m_comm [OF a_in_G zs_sum_in_G] by simp

        have eq2: "rev_get (length ys) (\<lambda>k. get (app xs [a]) k \<otimes>\<^bsub>G\<^esub> get ys k) =
              app (rev_get (length zs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get zs k )) [a \<otimes>\<^bsub>G\<^esub> b]"
          apply (rule_tac getFaithful)
          using length_eq
          unfolding app_length zs_def apply simp
          apply (simp add: get_rev_get)
        proof-
          fix n
          assume "n < length ys"
          then have "n < length xs \<or> n = length xs"
            using length_eq
            unfolding app_length by auto
          then show "get (app xs [a]) n \<otimes>\<^bsub>G\<^esub> get ys n =
         get (app (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get (rev_get (length xs) (get ys)) k)) [a \<otimes>\<^bsub>G\<^esub> b]) n"
          proof
            assume "n < length xs"
            then have nl: "n < length (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get (rev_get (length xs) (get ys)) k))" 
              by simp
            show "get (app xs [a]) n \<otimes>\<^bsub>G\<^esub> get ys n =
    get (app (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get (rev_get (length xs) (get ys)) k)) [a \<otimes>\<^bsub>G\<^esub> b]) n"
              unfolding getAppLemma [OF \<open>n < length xs\<close>]
                        getAppLemma [OF nl]
                        get_rev_get [OF \<open>n < length xs\<close>]
              by simp
          next
            assume "n = length xs"
            then have nl : "n = length (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get (rev_get (length xs) (get ys)) k))" 
              by simp
            show "get (app xs [a]) n \<otimes>\<^bsub>G\<^esub> get ys n =
    get (app (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get (rev_get (length xs) (get ys)) k)) [a \<otimes>\<^bsub>G\<^esub> b]) n"
              apply (subst \<open>n = length xs\<close>)
              unfolding getAppLemma2
              apply (rule_tac reverse_equality)
              apply (subst nl)
              unfolding getAppLemma2
              apply (subst \<open>n = length xs\<close>)
              unfolding b_def by simp
          qed
        qed
        show "local.sum (rev_get (length ys) (\<lambda>k. get (app xs [a]) k \<otimes>\<^bsub>G\<^esub> get ys k)) =
       local.sum (app xs [a]) \<otimes>\<^bsub>G\<^esub> local.sum ys"
          apply (subst eq1)
          apply (subst eq2)
          apply (subst app_sum)
            apply (simp add: a_in_G b_in_G)
           apply (simp add: get_rev_get)
          using zs_in_G xs_in_G \<open>length zs = length xs\<close> apply simp
          apply (subst zs_sum_eq)
          by (simp add: a_in_G b_in_G)
      qed
    qed
  qed
  then show "\<forall>k<length ys. get ys k \<in> carrier G \<Longrightarrow>
    \<forall>k<length xs. get xs k \<in> carrier G \<Longrightarrow>
    length xs = length ys \<Longrightarrow>
    local.sum (rev_get (length xs) (\<lambda>k. get xs k \<otimes>\<^bsub>G\<^esub> get ys k)) = local.sum xs \<otimes>\<^bsub>G\<^esub> local.sum ys"
    unfolding P_def by auto
qed

definition push_forward :: "nat \<times> nat list \<Rightarrow> 'a list \<Rightarrow> 'a list" where
  "push_forward ns xs = rev_get (fst ns) (\<lambda>k. sum (merge_with_zeros xs (\<lambda>i. get (snd ns) i = k)))"


lemma push_forward_length [simp]: "length (push_forward ns as) = fst ns"
  unfolding push_forward_def by simp

lemma push_forward_sum : 
  "\<And> ns. fin_set.Arr' ns \<Longrightarrow> (\<forall>k < length as. get as k \<in> carrier G) 
\<Longrightarrow> length (snd ns) = length as \<Longrightarrow> sum (push_forward ns as) = sum as"
  apply (induction as)
   apply (simp add: push_forward_def)
   apply (subst zero_sum)
    apply (simp add: get_rev_get)
  unfolding merge_with_zeros_def
    apply simp
   apply simp
proof-
  fix a as 
  fix ns :: "nat \<times> nat list"
  assume ind: " (\<And>ns. fin_set.Arr' ns \<Longrightarrow>
              \<forall>k<length as. get as k \<in> carrier G \<Longrightarrow>
              length (snd ns) = length as \<Longrightarrow> local.sum (push_forward ns as) = local.sum as)"
  assume "fin_set.Arr' ns" 
  assume aas_in_G: "\<forall>k<length (a # as). get (a # as) k \<in> carrier G"
  then have as_in_G: "\<forall>k < length as. get as k \<in> carrier G" by auto
  from aas_in_G have a_in_G: "a \<in> carrier G" by auto
  assume length_eq: "length (snd ns) = length (a # as)"
  then have "0 < length (snd ns)" by simp
  then have "get (snd ns) 0 < fst ns"
    using \<open>fin_set.Arr' ns\<close>
    unfolding fin_set.Arr'_def by simp
  have a_sum_eq: "a = sum (rev_get (fst ns)
       (\<lambda>k. (if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)))"
    apply (subst one_sum)
     apply auto
    using \<open>get (snd ns) 0 < fst ns\<close> apply simp
      apply (simp add: get_rev_get)
    apply (subst get_rev_get)
    using \<open>get (snd ns) 0 < fst ns\<close> apply simp
    using a_in_G apply simp
    apply (subst get_rev_get)
    using \<open>get (snd ns) 0 < fst ns\<close> apply simp
    by simp

  from \<open>0 < length (snd ns)\<close>
  have "snd ns \<noteq> []" by simp
  then obtain m ms where ms_def: "snd ns = m # ms" 
    using list.exhaust by auto
  have as_sum_eq: "local.sum (push_forward (fst ns, ms) as) = local.sum as"
    apply (rule_tac ind)
    using \<open>fin_set.Arr' ns\<close>
    unfolding fin_set.Arr'_def ms_def apply auto[1]
    using as_in_G apply simp
    using length_eq apply simp
    unfolding ms_def by simp

  have eq1: " (rev_get (length (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)))
       (\<lambda>k. get (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)) k \<otimes>\<^bsub>G\<^esub>
            get (push_forward (fst ns, ms) as) k)) = 
           (rev_get (fst ns)
       (\<lambda>k. (if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>) \<otimes>\<^bsub>G\<^esub>
            local.sum (merge_with_zeros as (\<lambda>i. get (snd ns) (Suc i) = k))))"
    apply (rule_tac getFaithful)
     apply simp
    apply (simp add: get_rev_get)
    unfolding push_forward_def apply (simp add: get_rev_get)
    unfolding ms_def by simp

  show "local.sum (push_forward ns (a # as)) = local.sum (a # as)"
    unfolding push_forward_def
    apply (subst merge_with_zeros_add)
    apply simp
    apply (rule_tac reverse_equality)
    apply (subst a_sum_eq)
    apply (subst reverse_equality [OF as_sum_eq])
    apply (subst reverse_equality [OF binary_sum_sum])
  proof-
    show "\<forall>k<length (push_forward (fst ns, ms) as). get (push_forward (fst ns, ms) as) k \<in> carrier G"
      unfolding push_forward_def merge_with_zeros_def
      apply (simp add: get_rev_get)
      apply auto
      apply (rule_tac sum_carrier)
      apply (simp add: get_rev_get)
      using as_in_G by simp
    show "\<forall>k<length (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)).
       get (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)) k \<in> carrier G"
      apply (simp add: get_rev_get)
      using a_in_G by simp
    show "length (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)) = length (push_forward (fst ns, ms) as)"
      unfolding push_forward_def by simp
    show "local.sum
     (rev_get (length (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)))
       (\<lambda>k. get (rev_get (fst ns) (\<lambda>k. if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>)) k \<otimes>\<^bsub>G\<^esub>
            get (push_forward (fst ns, ms) as) k)) =
    local.sum
     (rev_get (fst ns)
       (\<lambda>k. (if get (snd ns) 0 = k then a else \<one>\<^bsub>G\<^esub>) \<otimes>\<^bsub>G\<^esub>
            local.sum (merge_with_zeros as (\<lambda>i. get (snd ns) (Suc i) = k))))"
      apply (subst eq1)
      by simp
  qed
qed


lemma push_forward_carrier : 
  assumes as_in_G: "\<forall>k < length as. get as k \<in> carrier G"
  and "k < fst f"
shows "get (push_forward f as) k \<in> carrier G"
  unfolding push_forward_def
  apply (simp add: get_rev_get [OF \<open>k < fst f\<close>])
  apply (rule_tac sum_carrier)
  apply (simp add: merge_with_zeros_def get_rev_get)
  using as_in_G by simp

lemma push_forward_merge_with_zero : 
      "push_forward ns (merge_with_zeros as (\<lambda>k. (P (get (snd ns) k)))) =
       merge_with_zeros (push_forward ns as) P"
  apply (rule_tac getFaithful)
   apply simp
  apply simp
  apply (subst push_forward_def)
  apply (rule_tac reverse_equality)
  apply (subst merge_with_zeros_def)
  apply (simp add: get_rev_get)
  apply auto
proof-
  fix n
  assume "n < fst ns"
  assume "P n"
  have list_eq: "rev_get (length as) (\<lambda>k. if get (snd ns) k = n then get as k else \<one>\<^bsub>G\<^esub>) =
              (rev_get (length as) (\<lambda>k. if get (snd ns) k = n
        then get (rev_get (length as) (\<lambda>k. if P (get (snd ns) k) then get as k else \<one>\<^bsub>G\<^esub>)) k else \<one>\<^bsub>G\<^esub>))"
    apply (rule_tac getFaithful)
     apply simp
    by (simp add: get_rev_get \<open>P n\<close>)
  show "get (push_forward ns as) n =
         local.sum (merge_with_zeros (merge_with_zeros as (\<lambda>k. P (get (snd ns) k))) (\<lambda>i. get (snd ns) i = n))"
    unfolding merge_with_zeros_def push_forward_def 
    apply (simp add: get_rev_get [OF \<open>n < fst ns\<close>])
    apply (subst list_eq)
    by simp
next
  fix n
  assume "n < fst ns"
  assume "\<not> P n"
  show "\<one>\<^bsub>G\<^esub> = local.sum (merge_with_zeros 
      (merge_with_zeros as (\<lambda>k. P (get (snd ns) k))) (\<lambda>i. get (snd ns) i = n))"
    apply (rule_tac reverse_equality [OF zero_sum])
    apply simp
    unfolding merge_with_zeros_def
    by (simp add: get_rev_get \<open>\<not> P n\<close>)
qed


lemma merge_with_zeros_carrier : assumes as_in_G: "\<forall>k<length as. get as k \<in> carrier G"
  shows "\<forall>k < length (merge_with_zeros as P). get (merge_with_zeros as P) k \<in> carrier G"
  apply simp
  unfolding merge_with_zeros_def
  by (simp add: get_rev_get as_in_G)


lemma push_forward_sum_with_prop : assumes
    "fin_set.Arr' ns"
 and as_in_G: "\<forall>k<length as. get as k \<in> carrier G"
 and "length (snd ns) = length as"
    shows "sum (merge_with_zeros as (\<lambda>k. (P (get (snd ns) k)))) =
         sum (merge_with_zeros (push_forward ns as) P)"
  apply (subst reverse_equality [OF push_forward_merge_with_zero])
  apply (subst push_forward_sum 
        [OF \<open>fin_set.Arr' ns\<close> 
         merge_with_zeros_carrier [OF as_in_G]])
  using \<open>length (snd ns) = length as\<close> apply simp
  by simp



lemma push_forward_id : assumes "length as = n" 
   and as_in_G: "\<forall>k < length as. get as k \<in> carrier G"
  shows "push_forward (fin_set.Id' n) as = as"
  unfolding push_forward_def
  apply (rule_tac getFaithful)
   apply (simp add: fin_set.Id'_def \<open>length as = n\<close>)
  apply (simp add: get_rev_get)
  unfolding fin_set.Id'_def 
  apply simp
  unfolding merge_with_zeros_def
proof-
  fix m
  assume "m < n"
  have eq1: "rev_get (length as) (\<lambda>k. if get (rev_get n (\<lambda>k. k)) k = m then get as k else \<one>\<^bsub>G\<^esub>) =
        rev_get (length as) (\<lambda>k. if k = m then get as k else \<one>\<^bsub>G\<^esub>)"
    apply (rule_tac getFaithful)
     apply simp
    by (simp add: get_rev_get \<open>m < n\<close> \<open>length as = n\<close>)
  show "local.sum (rev_get (length as) (\<lambda>k. if get (rev_get n (\<lambda>k. k)) k = m then get as k else \<one>\<^bsub>G\<^esub>)) =
          get as m"
    apply (subst eq1)
    apply (subst one_sum)
     apply safe
    unfolding \<open>length as = n\<close>
    using \<open>m < n\<close> apply simp
      apply (simp add: get_rev_get)
    using \<open>m < n\<close> apply (simp add: get_rev_get)
    using as_in_G
    unfolding \<open>length as = n\<close> apply simp
    using \<open>m < n\<close> by (simp add: get_rev_get)
qed

lemma push_forward_comp : 
  assumes "length (snd g) = length as"
   and "fin_set.Arr' g"
  and as_in_G: "\<forall>k<length as. get as k \<in> carrier G" 
   shows "push_forward (fin_set.Comp' f g) as =
            push_forward f (push_forward g as)"
  apply (subst push_forward_def)
  apply (subst push_forward_def)
  apply (rule_tac getFaithful)
   apply (simp add: fin_set.Comp'_def)
  apply (simp add: get_rev_get)
  apply (subst get_rev_get)
   apply (simp add: fin_set.Comp'_def)
proof-
  fix n
  assume "n < fst (fin_set.Comp' f g)"
  then have "n < fst f"
    unfolding fin_set.Comp'_def by simp
  have eq1: "merge_with_zeros as (\<lambda>i. get (rev_get (length (snd g)) (\<lambda>n. get (snd f) (get (snd g) n))) i = n)
             = merge_with_zeros as (\<lambda>i. get (snd f) (get (snd g) i) = n)"
    apply (rule_tac getFaithful)
     apply simp
    apply simp
    unfolding merge_with_zeros_def
              \<open>length (snd g) = length as\<close>
    by (simp add: get_rev_get)


  show "local.sum (merge_with_zeros as (\<lambda>i. get (snd (fin_set.Comp' f g)) i = n)) =
         local.sum (merge_with_zeros (push_forward g as) (\<lambda>i. get (snd f) i = n))"
    unfolding fin_set.Comp'_def apply simp
    apply (subst eq1)
    by (rule_tac push_forward_sum_with_prop 
           [OF \<open>fin_set.Arr' g\<close> as_in_G \<open>length (snd g) = length as\<close>])
qed









definition A :: "'a LC pointed_set" where 
  "A = (Just \<one>\<^bsub>G\<^esub>, Just ` (carrier G))"

lemma lacan: "Obj' A"
  unfolding A_def Obj'_def by simp

definition A_tothe :: "nat \<Rightarrow> 'a LC pointed_set" where
  "A_tothe n = pointed_product (rev_get n (\<lambda>k. A))"

lemma A_tothe_obj : "Obj' (A_tothe n)"
  unfolding A_tothe_def
  apply (rule_tac pointed_product_obj)
  apply (simp add: get_rev_get)
  using lacan by simp

lemma x_in_A_tothe_char : "x \<in> snd (A_tothe n) \<Longrightarrow> \<exists> xs. x = Join xs \<and>
             length xs = n \<and>
             (\<forall>k < n. get xs k \<in> snd A)"
  unfolding A_tothe_def by (simp add: get_rev_get)

lemma xs_in_A_char : assumes xs_def:  "x = Join xs \<and> length xs = n \<and>
             (\<forall>k < n. get xs k \<in> snd A)"
  shows "\<exists> as. xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G) \<and>
                (SOME as. Join (fmap Just as) = x) = as" 
proof-
  have H: "\<forall>k < length xs. get xs k \<in> Just ` (carrier G)"
    using xs_def
    unfolding A_def by simp
  from fmap_image [OF H] obtain as where as_def : "xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G)"
    by auto
  show "\<exists>as. xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G)\<and>
                (SOME as. Join (fmap Just as) = x) = as"
  proof
    show "xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G) \<and> (SOME as. Join (fmap Just as) = x) = as"
      apply (simp add: as_def)
    proof
      show as_eq: "Join (rev_get (length as) (\<lambda>n. Just (get as n))) = x"
        using as_def xs_def by simp
      fix bs
      assume "Join (rev_get (length bs) (\<lambda>n. Just (get bs n))) = x"
      then have fmap_eq: "fmap Just bs = fmap Just as"
        using as_eq by auto
      show "bs = as"
        using fmap_preserves_inj[OF fmap_eq] 
        by simp
    qed
  qed
qed


definition H_on_arrow :: "gamma \<Rightarrow> 'a LC \<Rightarrow> 'a LC" where
  "H_on_arrow f x = Join (fmap Just (push_forward (the f) (SOME as. Join (fmap Just as) = x)))"




definition HFunctor :: "gamma \<Rightarrow> 'a LC parr option" where
  "HFunctor = MkFunctor fin_set.comp pointed_set_comp
               (\<lambda>f. Some (MkArr (A_tothe (fin_set.Dom' (the f))) 
                                (A_tothe (fin_set.Cod' (the f))) 
                                (H_on_arrow f)))"


lemma HFunctor_arr: assumes arr_f : "partial_magma.arr fin_set.comp f"
  shows "partial_magma.arr pointed_set_comp (HFunctor f)"
  unfolding pointed_set_comp_def
  apply (subst classical_category.arr_char [OF ccpf])
  apply (subst HFunctor_def)
  apply (simp add: arr_f)
  unfolding Arr'_def setcat.Arr_def apply auto
proof-
  show "fst (the (HFunctor f)) \<in> extensional (snd (fst (snd (the (HFunctor f)))))"
    unfolding HFunctor_def
    using arr_f apply simp
    unfolding MkArr_def by simp
  fix x
  assume "x \<in> snd (fst (snd (the (HFunctor f))))"
  then have x_in_dom: "x \<in> snd (A_tothe (length (snd (the f))))"
    unfolding HFunctor_def
    using arr_f apply simp
    unfolding MkArr_def by simp
  obtain xs where xs_def: "x = Join xs \<and>
             length xs = length (snd (the f)) \<and>
             (\<forall>n<length (snd (the f)).
                 get xs n \<in> snd A)"
    using x_in_A_tothe_char [OF x_in_dom]
    by auto
  obtain as where as_def: "xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G) \<and> 
                   (SOME as. Join (fmap Just as) = x) = as"
    using xs_in_A_char [OF xs_def] 
    by auto
  then have some_as : "(SOME as. Join (fmap Just as) = x) = as" by simp
  from as_def have as_in_G: "(\<forall>k<length as. get as k \<in> carrier G)"
    by simp

  have pf_in_G: "\<forall>n<fst (the f). get (push_forward (the f) as) n \<in> carrier G"
    apply auto
    unfolding push_forward_def
    apply (simp add: get_rev_get)
    apply (rule_tac sum_carrier)
    unfolding merge_with_zeros_def
    apply (simp add: get_rev_get)
    using as_in_G by simp

  show "fst (the (HFunctor f)) x \<in> snd (snd (snd (the (HFunctor f))))"
    unfolding HFunctor_def
    apply (simp add: arr_f)
    unfolding MkArr_def apply (simp add: x_in_dom)
    unfolding H_on_arrow_def
    apply (subst some_as)
    unfolding A_tothe_def apply (simp add: get_rev_get)
    unfolding A_def apply simp
    using pf_in_G by simp
next
  show "Obj' (fst (snd (the (HFunctor f))))"
    unfolding HFunctor_def MkArr_def
    using arr_f apply simp
    using A_tothe_obj.
  show "Obj' (snd (snd (the (HFunctor f))))"
    unfolding HFunctor_def MkArr_def
    using arr_f apply simp
    using A_tothe_obj.
  show "fst (the (HFunctor f)) (fst (fst (snd (the (HFunctor f))))) = fst (snd (snd (the (HFunctor f))))"
    unfolding HFunctor_def MkArr_def
    using arr_f A_tothe_obj
    unfolding Obj'_def apply simp
  proof-
    have fst_A_eq: "\<And>n. Join (fmap Just (rev_get n (\<lambda>k. \<one>\<^bsub>G\<^esub>))) = fst (A_tothe n)"
      unfolding A_tothe_def apply simp
      apply (rule_tac getFaithful)
       apply simp
      apply (simp add: get_rev_get)
      unfolding A_def by simp
    have some_eq: "(SOME as. Join (fmap Just as) = fst (A_tothe (length (snd (the f))))) =
                      rev_get (length (snd (the f))) (\<lambda>k. \<one>\<^bsub>G\<^esub>)"
    proof
      show "Join (fmap Just (rev_get (length (snd (the f))) (\<lambda>k. \<one>\<^bsub>G\<^esub>))) = fst (A_tothe (length (snd (the f))))"
        using fst_A_eq.
      fix as
      assume "Join (fmap Just as) = fst (A_tothe (length (snd (the f))))"
      then have fmap_eq: "fmap Just as = fmap Just (rev_get (length (snd (the f))) (\<lambda>k. \<one>\<^bsub>G\<^esub>))"
        unfolding reverse_equality [OF fst_A_eq] by simp
      show "as = rev_get (length (snd (the f))) (\<lambda>k. \<one>\<^bsub>G\<^esub>)" 
        using fmap_preserves_inj [OF fmap_eq] by simp
    qed
    have eq1: "(push_forward (the f) (rev_get (length (snd (the f))) (\<lambda>k. \<one>\<^bsub>G\<^esub>))) = 
            (rev_get (fst (the f)) (\<lambda>k. \<one>\<^bsub>G\<^esub>))"
      unfolding push_forward_def
      apply (rule_tac getFaithful)
       apply simp
      apply (simp add: get_rev_get)
      apply (rule_tac zero_sum)
      unfolding merge_with_zeros_def
      by (simp add: get_rev_get)
    show "H_on_arrow f (fst (A_tothe (length (snd (the f))))) = fst (A_tothe (fst (the f)))"
      unfolding H_on_arrow_def
      apply (subst some_eq)
      apply (subst reverse_equality [OF fst_A_eq])
      using eq1 by simp
  qed
qed

lemma HFunctor_Id: "the (HFunctor (Some (fin_set.Id' n))) = Id' (A_tothe n)"
  apply (rule_tac fun_eq_char)
proof-
  have "fin_set.Arr' (fin_set.Id' n)"
    using classical_category.Arr_Id [OF fin_set.is_classical_category]
    by simp
  then have arr_id: "partial_magma.arr fin_set.comp (Some (fin_set.Id' n))"
    unfolding fin_set.comp_def
    using classical_category.arr_char [OF fin_set.is_classical_category]
    by simp
  then have "partial_magma.arr pointed_set_comp (HFunctor (Some (fin_set.Id' n)))"
    apply (rule_tac HFunctor_arr)
    by simp
  then show "Arr' (the (HFunctor (Some (fin_set.Id' n))))"
    using classical_category.arr_char [OF ccpf]
    unfolding reverse_equality [OF pointed_set_comp_def]
    by blast
  show "Arr' (Id' (A_tothe n))"
    using classical_category.Arr_Id [OF ccpf A_tothe_obj].
  show "fst (snd (the (HFunctor (Some (fin_set.Id' n))))) = fst (snd (Id' (A_tothe n)))"
    unfolding HFunctor_def MkArr_def 
    using arr_id apply simp
    unfolding Id'_def fin_set.Id'_def by simp
  show "snd (snd (the (HFunctor (Some (fin_set.Id' n))))) = snd (snd (Id' (A_tothe n)))"
    unfolding HFunctor_def MkArr_def 
    using arr_id apply simp
    unfolding Id'_def fin_set.Id'_def by simp
  fix x
  assume "x \<in> snd (fst (snd (the (HFunctor (Some (fin_set.Id' n))))))"
  then have x_in_dom : "x \<in> snd (A_tothe (length (snd (fin_set.Id' n))))"
    unfolding HFunctor_def MkArr_def
    using arr_id by simp
  then obtain xs where xs_def: "x = Join xs \<and>
         length xs = length (snd (fin_set.Id' n)) \<and> (\<forall>k<length (snd (fin_set.Id' n)). get xs k \<in> snd A)"
    using x_in_A_tothe_char [OF x_in_dom] by auto
  then obtain as where as_def: "xs = fmap Just as \<and> (\<forall>k<length xs. get as k \<in> carrier G) \<and> (SOME as. Join (fmap Just as) = x) = as"
    using xs_in_A_char [OF xs_def] by auto
  then have some_eq : "(SOME as. Join (fmap Just as) = x) = as" by simp
  have "n = length as"
    using xs_def
    unfolding fin_set.Id'_def
    using as_def by simp

  show "fst (the (HFunctor (Some (fin_set.Id' n)))) x = fst (Id' (A_tothe n)) x"
    unfolding HFunctor_def MkArr_def
    apply (simp add: arr_id x_in_dom)
    unfolding H_on_arrow_def some_eq
    apply simp
    apply (subst push_forward_id)
    using as_def xs_def apply (simp add: fin_set.Id'_def)
    using as_def apply simp
    using x_in_dom
    unfolding fin_set.Id'_def Id'_def apply simp
    apply (simp add: xs_def)
    by (simp add: as_def \<open>n = length as\<close>)
qed



lemma "functor fin_set.comp pointed_set_comp HFunctor"
  unfolding functor_def
  apply (simp add: fin_set.is_category is_category)
  unfolding functor_axioms_def
  apply auto
proof-
  fix f
  show "\<not> partial_magma.arr fin_set.comp f \<Longrightarrow> HFunctor f = partial_magma.null pointed_set_comp"
    unfolding HFunctor_def by simp
  assume arr_f : "partial_magma.arr fin_set.comp f" 
  show arr_hf: "partial_magma.arr pointed_set_comp (HFunctor f)"
    using HFunctor_arr [OF arr_f].
  have arr_id : "\<And>n. partial_magma.arr fin_set.comp (Some (fin_set.Id' n))"
    unfolding fin_set.comp_def
    apply (subst classical_category.arr_char [OF fin_set.is_classical_category])
    using classical_category.Arr_Id [OF fin_set.is_classical_category]
    by simp

  show "partial_magma.dom pointed_set_comp (HFunctor f) = HFunctor (partial_magma.dom fin_set.comp f)"
    unfolding pointed_set_comp_def
    apply (subst classical_category.dom_char [OF ccpf])
    unfolding reverse_equality [OF pointed_set_comp_def]
    apply (simp add: arr_hf)
    unfolding fin_set.comp_def
    apply (subst classical_category.dom_char [OF fin_set.is_classical_category])
    unfolding reverse_equality [OF fin_set.comp_def]
    apply (simp add: arr_f)
    apply (subst HFunctor_def)
    unfolding MkArr_def apply (simp add: arr_f)
    apply (subst reverse_equality [OF HFunctor_Id])
    unfolding HFunctor_def by (simp add: arr_id)
  show "partial_magma.cod pointed_set_comp (HFunctor f) = HFunctor (partial_magma.cod fin_set.comp f)"
    unfolding pointed_set_comp_def
    apply (subst classical_category.cod_char [OF ccpf])
    unfolding reverse_equality [OF pointed_set_comp_def]
    apply (simp add: arr_hf)
    unfolding fin_set.comp_def
    apply (subst classical_category.cod_char [OF fin_set.is_classical_category])
    unfolding reverse_equality [OF fin_set.comp_def]
    apply (simp add: arr_f)
    apply (subst HFunctor_def)
    unfolding MkArr_def apply (simp add: arr_f)
    apply (subst reverse_equality [OF HFunctor_Id])
    unfolding HFunctor_def by (simp add: arr_id)
next
  fix g f
  assume arr_gf: "partial_magma.arr fin_set.comp (fin_set.comp g f)"





    oops

end


end
